{% extends "onboarding/base.html" %}
{% load i18n %}
{% load static %}
{% load django_vite %}

{% block onboarding_content %}
<div class="app-card p-8">
  <div class="text-center mb-8">
    <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary/10 mb-4">
      <i class="fa-solid fa-sync fa-spin text-2xl text-primary"></i>
    </div>
    <h1 class="text-2xl font-semibold mb-2">{% translate "Syncing Your Data" %}</h1>
    <p class="text-base-content/70">
      {% translate "We're importing your GitHub history. This usually takes a few minutes." %}
    </p>
  </div>

  {# Pipeline steps indicator #}
  <div class="mb-8">
    <ul class="steps steps-horizontal w-full text-xs">
      <li id="step-members" class="step" data-content="1">
        <span class="step-label hidden sm:inline">{% translate "Members" %}</span>
      </li>
      <li id="step-sync" class="step" data-content="2">
        <span class="step-label hidden sm:inline">{% translate "PRs" %}</span>
      </li>
      <li id="step-llm" class="step" data-content="3">
        <span class="step-label hidden sm:inline">{% translate "AI Analysis" %}</span>
      </li>
      <li id="step-metrics" class="step" data-content="4">
        <span class="step-label hidden sm:inline">{% translate "Metrics" %}</span>
      </li>
      <li id="step-insights" class="step" data-content="5">
        <span class="step-label hidden sm:inline">{% translate "Insights" %}</span>
      </li>
    </ul>
  </div>

  {# Current phase details #}
  <div class="mb-8 p-4 bg-base-200 rounded-lg">
    <div class="flex items-center gap-3 mb-3">
      <i id="phase-icon" class="fa-solid fa-sync fa-spin text-primary text-lg"></i>
      <span id="progress-message" class="text-base-content font-medium">{% translate "Starting sync..." %}</span>
    </div>

    {# Progress bar for current phase #}
    <div class="mb-2">
      <div class="flex justify-between text-sm mb-1">
        <span id="phase-detail" class="text-base-content/60"></span>
        <span id="progress-percent" class="font-mono text-base-content">0%</span>
      </div>
      <div class="w-full bg-base-300 rounded-full h-2">
        <div id="progress-bar" class="bg-primary h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
      </div>
    </div>

    <div class="text-center">
      <span id="estimated-time" class="text-sm text-base-content/60">
        <i class="fa-regular fa-clock mr-1"></i>
        {% translate "Calculating..." %}
      </span>
    </div>
  </div>

  {# First insights ready banner #}
  {% if first_insights_ready %}
  <div id="first-insights-banner" class="alert alert-success mb-8">
    <i class="fa-solid fa-chart-line"></i>
    <span>{% translate "First insights are ready! View your initial dashboard while the full sync continues." %}</span>
    <a href="{% url 'web_team:home' %}" class="btn btn-sm btn-primary">
      {% translate "View Dashboard" %}
    </a>
  </div>
  {% endif %}

  {# Repository list with status #}
  {% if repos %}
  <div class="border border-base-300 rounded-lg divide-y divide-base-300 mb-8">
    {% for repo in repos %}
    <div class="flex items-center justify-between p-4" id="repo-{{ repo.id }}">
      <div class="flex items-center gap-3">
        <i class="fa-brands fa-github text-base-content/50"></i>
        <span class="font-medium">{{ repo.full_name }}</span>
      </div>
      <div class="repo-status">
        <span class="badge badge-ghost text-base-content/50">
          <i class="fa-solid fa-clock mr-1"></i>
          {% translate "Pending" %}
        </span>
      </div>
    </div>
    {% endfor %}
  </div>
  {% else %}
  <div class="text-center text-base-content/70 py-8">
    {% translate "No repositories selected for sync." %}
  </div>
  {% endif %}

  {# Actions #}
  <div id="sync-actions" class="text-center">
    <p class="text-sm text-base-content/70 mb-4">
      {% translate "You can safely close this page. The sync will continue in the background." %}
    </p>
    {% if next_step == "copilot" %}
    <a href="{% url 'onboarding:connect_copilot' %}" class="app-btn-secondary mt-4">
      {% translate "Continue to Copilot" %}
    </a>
    {% elif next_step == "jira" %}
    <a href="{% url 'onboarding:connect_jira' %}" class="app-btn-secondary mt-4">
      {% translate "Continue to Jira" %}
    </a>
    {% elif next_step == "slack" %}
    <a href="{% url 'onboarding:connect_slack' %}" class="app-btn-secondary mt-4">
      {% translate "Continue to Slack" %}
    </a>
    {% else %}
    <a href="{% url 'onboarding:complete' %}" class="app-btn-secondary mt-4">
      {% translate "Continue to Dashboard" %}
    </a>
    {% endif %}
  </div>

  {# Completion section (hidden by default) #}
  <div id="sync-complete" class="hidden text-center">
    <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-success/10 mb-4">
      <i class="fa-solid fa-check text-2xl text-success"></i>
    </div>
    <h2 class="text-xl font-semibold mb-2">{% translate "Sync Complete!" %}</h2>
    <p class="text-base-content/70 mb-6">
      {% translate "Your data is ready. Let's continue setting up your team." %}
    </p>
    {% if next_step == "copilot" %}
    <a href="{% url 'onboarding:connect_copilot' %}" class="app-btn-primary">
      {% translate "Continue to Copilot" %}
      <i class="fa-solid fa-arrow-right ml-2"></i>
    </a>
    {% elif next_step == "jira" %}
    <a href="{% url 'onboarding:connect_jira' %}" class="app-btn-primary">
      {% translate "Continue to Jira" %}
      <i class="fa-solid fa-arrow-right ml-2"></i>
    </a>
    {% elif next_step == "slack" %}
    <a href="{% url 'onboarding:connect_slack' %}" class="app-btn-primary">
      {% translate "Continue to Slack" %}
      <i class="fa-solid fa-arrow-right ml-2"></i>
    </a>
    {% else %}
    <a href="{% url 'onboarding:complete' %}" class="app-btn-primary">
      {% translate "Continue to Dashboard" %}
      <i class="fa-solid fa-arrow-right ml-2"></i>
    </a>
    {% endif %}
  </div>

  {# Error/Stuck section (hidden by default) #}
  <div id="sync-error" class="hidden text-center">
    <div class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-warning/10 mb-4">
      <i class="fa-solid fa-exclamation-triangle text-2xl text-warning"></i>
    </div>
    <h2 class="text-xl font-semibold mb-2">{% translate "Sync May Have Stalled" %}</h2>
    <p id="sync-error-message" class="text-base-content/70 mb-6">
      {% translate "The sync hasn't made progress in a while. This could be temporary." %}
    </p>
    <div class="flex flex-col sm:flex-row gap-4 justify-center">
      <button id="retry-sync-btn" class="app-btn-primary">
        <i class="fa-solid fa-redo mr-2"></i>
        {% translate "Retry Sync" %}
      </button>
      {% if next_step == "copilot" %}
      <a href="{% url 'onboarding:connect_copilot' %}" class="app-btn-secondary">
        {% translate "Skip for Now" %}
        <i class="fa-solid fa-arrow-right ml-2"></i>
      </a>
      {% elif next_step == "jira" %}
      <a href="{% url 'onboarding:connect_jira' %}" class="app-btn-secondary">
        {% translate "Skip for Now" %}
        <i class="fa-solid fa-arrow-right ml-2"></i>
      </a>
      {% elif next_step == "slack" %}
      <a href="{% url 'onboarding:connect_slack' %}" class="app-btn-secondary">
        {% translate "Skip for Now" %}
        <i class="fa-solid fa-arrow-right ml-2"></i>
      </a>
      {% else %}
      <a href="{% url 'onboarding:complete' %}" class="app-btn-secondary">
        {% translate "Skip for Now" %}
        <i class="fa-solid fa-arrow-right ml-2"></i>
      </a>
      {% endif %}
    </div>
    <p class="text-sm text-base-content/50 mt-4">
      {% translate "You can always re-sync from Settings > Integrations later." %}
    </p>
  </div>
</div>

{# Hidden data for JavaScript #}
<script type="application/json" id="sync-config">
{
  "startUrl": "{% url 'onboarding:start_sync' %}",
  "statusUrl": "{% url 'onboarding:sync_status' %}",
  "csrfToken": "{{ csrf_token }}",
  "reposCount": {{ repos|length }}
}
</script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const config = JSON.parse(document.getElementById('sync-config').textContent);
  const progressBar = document.getElementById('progress-bar');
  const progressPercent = document.getElementById('progress-percent');
  const progressMessage = document.getElementById('progress-message');
  const phaseDetail = document.getElementById('phase-detail');
  const phaseIcon = document.getElementById('phase-icon');
  const estimatedTime = document.getElementById('estimated-time');
  const estimatedTimeIcon = estimatedTime.querySelector('i');
  const syncActions = document.getElementById('sync-actions');
  const syncComplete = document.getElementById('sync-complete');
  const syncError = document.getElementById('sync-error');
  const syncErrorMessage = document.getElementById('sync-error-message');
  const retrySyncBtn = document.getElementById('retry-sync-btn');

  // Step indicator elements
  const stepElements = {
    members: document.getElementById('step-members'),
    sync: document.getElementById('step-sync'),
    llm: document.getElementById('step-llm'),
    metrics: document.getElementById('step-metrics'),
    insights: document.getElementById('step-insights')
  };

  // Phase to step mapping
  const phaseToStep = {
    'members': 1, 'syncing_members': 1,
    'sync': 2, 'syncing': 2, 'phase1': 2,
    'llm': 3, 'llm_processing': 3,
    'metrics': 4, 'computing_metrics': 4,
    'insights': 5, 'computing_insights': 5,
    'complete': 6, 'phase1_complete': 6,
    'phase2': 6, 'background_syncing': 6,
    'done': 6
  };

  // Time tracking for estimation and stall detection
  let syncStartTime = null;
  let lastProgressTime = null;
  let lastProgressPercent = 0;
  let lastPrCount = 0;
  let lastRepoActivity = 0;  // Track repo progress changes
  let stallTimeoutMs = 90000; // 90 seconds without progress = stalled (increased for LLM)
  let isPolling = false;

  // Calculate repo activity score for stall detection
  // Sum of all repo sync_progress values + completed count * 100
  function calculateRepoActivity(repos) {
    if (!repos || !repos.length) return 0;
    return repos.reduce((sum, repo) => {
      const progress = repo.sync_progress || 0;
      const bonus = repo.sync_status === 'completed' ? 100 : 0;
      return sum + progress + bonus;
    }, 0);
  }
  let currentTaskId = null;
  let dbStatusInterval = null;
  let currentPhase = null;

  // Update step indicators based on current phase
  function updateStepIndicators(phase, currentStep) {
    const stepNum = phaseToStep[phase] || currentStep || 0;

    Object.entries(stepElements).forEach(([key, el]) => {
      if (!el) return;
      const elStep = phaseToStep[key];

      if (elStep < stepNum) {
        // Completed step
        el.classList.add('step-primary');
        el.setAttribute('data-content', 'âœ“');
      } else if (elStep === stepNum) {
        // Current step
        el.classList.add('step-primary');
      } else {
        // Future step
        el.classList.remove('step-primary');
      }
    });
  }

  // Update phase-specific details
  function updatePhaseDetails(data) {
    if (data.sync_phase && data.sync_phase !== currentPhase) {
      currentPhase = data.sync_phase;
      // Reset progress for new phase
      progressBar.style.width = '0%';
      progressPercent.textContent = '0%';
    }

    // Update phase icon
    const phase = data.sync_phase || data.pipeline_status;
    if (phase === 'complete' || phase === 'phase1_complete' || phase === 'done') {
      phaseIcon.className = 'fa-solid fa-check text-success text-lg';
    } else {
      phaseIcon.className = 'fa-solid fa-sync fa-spin text-primary text-lg';
    }

    // Update phase label
    if (data.sync_phase_label) {
      progressMessage.textContent = data.sync_phase_label;
    }

    // Update phase-specific detail
    let detailText = '';
    if (phase === 'llm' || phase === 'llm_processing') {
      if (data.llm_progress && data.llm_progress.total > 0) {
        detailText = data.llm_progress.processed + ' / ' + data.llm_progress.total + ' PRs analyzed';
        const llmPercent = Math.round((data.llm_progress.processed / data.llm_progress.total) * 100);
        progressBar.style.width = llmPercent + '%';
        progressPercent.textContent = llmPercent + '%';
      }
    } else if (phase === 'sync' || phase === 'syncing' || phase === 'phase1') {
      if (data.prs_synced > 0) {
        detailText = data.prs_synced + ' PRs imported';
      }
    } else if (phase === 'metrics' || phase === 'computing_metrics') {
      detailText = 'Aggregating weekly metrics...';
      progressBar.style.width = '50%';
      progressPercent.textContent = '50%';
    } else if (phase === 'insights' || phase === 'computing_insights') {
      detailText = 'Generating AI-powered insights...';
      progressBar.style.width = '50%';
      progressPercent.textContent = '50%';
    } else if (data.prs_synced > 0) {
      detailText = data.prs_synced + ' PRs synced';
    }

    phaseDetail.textContent = detailText;

    // Update step indicators
    updateStepIndicators(phase, data.current_step);
  }

  // Update estimated time remaining based on progress
  function updateEstimatedTime(percent) {
    if (percent <= 0 || !syncStartTime) {
      estimatedTimeIcon.className = 'fa-regular fa-clock mr-1';
      estimatedTime.lastChild.textContent = ' Calculating...';
      return;
    }

    if (percent >= 100) {
      estimatedTimeIcon.className = 'fa-solid fa-check mr-1';
      estimatedTime.lastChild.textContent = ' Complete!';
      return;
    }

    const elapsedMs = Date.now() - syncStartTime;
    const estimatedTotalMs = (elapsedMs / percent) * 100;
    const remainingMs = estimatedTotalMs - elapsedMs;
    const remainingSeconds = Math.ceil(remainingMs / 1000);

    let timeText;
    if (remainingSeconds < 60) {
      timeText = ' ' + remainingSeconds + ' second' + (remainingSeconds !== 1 ? 's' : '') + ' remaining';
    } else {
      const minutes = Math.ceil(remainingSeconds / 60);
      timeText = ' ~' + minutes + ' minute' + (minutes !== 1 ? 's' : '') + ' remaining';
    }

    estimatedTimeIcon.className = 'fa-regular fa-clock mr-1';
    estimatedTime.lastChild.textContent = timeText;
  }

  // Update individual repo status badges using safe DOM methods
  function updateRepoStatus(repoId, status, progress, error) {
    const repoRow = document.getElementById('repo-' + repoId);
    if (!repoRow) return;

    const statusDiv = repoRow.querySelector('.repo-status');
    if (!statusDiv) return;

    let badgeClass, iconClass, statusText;

    switch (status) {
      case 'completed':
        badgeClass = 'badge badge-success';
        iconClass = 'fa-solid fa-check mr-1';
        statusText = 'Completed';
        break;
      case 'syncing':
        badgeClass = 'badge badge-primary';
        iconClass = 'fa-solid fa-sync fa-spin mr-1';
        statusText = progress > 0 ? progress + '%' : 'Syncing...';
        break;
      case 'failed':
        badgeClass = 'badge badge-error';
        iconClass = 'fa-solid fa-times mr-1';
        statusText = 'Failed';
        break;
      default: // pending
        badgeClass = 'badge badge-ghost text-base-content/50';
        iconClass = 'fa-solid fa-clock mr-1';
        statusText = 'Pending';
    }

    // Clear existing content safely
    while (statusDiv.firstChild) {
      statusDiv.removeChild(statusDiv.firstChild);
    }

    // Create badge span
    const badge = document.createElement('span');
    badge.className = badgeClass;

    // Create icon
    const icon = document.createElement('i');
    icon.className = iconClass;
    badge.appendChild(icon);

    // Add text
    badge.appendChild(document.createTextNode(statusText));

    statusDiv.appendChild(badge);

    // Add error tooltip if failed
    if (status === 'failed' && error) {
      statusDiv.setAttribute('title', error);
    }
  }

  // Poll database for real-time status
  function pollDbStatus() {
    fetch(config.statusUrl)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          console.warn('Status error:', data.error);
          return;
        }

        // Update individual repo statuses
        if (data.repos) {
          data.repos.forEach(repo => {
            updateRepoStatus(repo.id, repo.sync_status, repo.sync_progress, repo.last_sync_error);
          });
        }

        // Update PR count in message if available
        if (data.prs_synced > 0 && progressMessage) {
          const currentText = progressMessage.textContent;
          // Only add PR count if not already showing it and we're in progress
          if (!currentText.includes('PR') && isPolling) {
            progressMessage.textContent = currentText + ' (' + data.prs_synced + ' PRs synced)';
          }
        }
      })
      .catch(error => {
        console.warn('Error fetching DB status:', error);
      });
  }

  // Show error/stalled state
  function showErrorState(message) {
    isPolling = false;
    if (dbStatusInterval) {
      clearInterval(dbStatusInterval);
      dbStatusInterval = null;
    }
    syncActions.classList.add('hidden');
    syncComplete.classList.add('hidden');
    syncError.classList.remove('hidden');
    if (message) {
      syncErrorMessage.textContent = message;
    }
    // Stop the spinner
    const syncIcon = document.querySelector('.fa-sync');
    if (syncIcon) {
      syncIcon.classList.remove('fa-spin');
      syncIcon.classList.remove('fa-sync');
      syncIcon.classList.add('fa-exclamation-circle');
    }
  }

  // Show completion state
  function showCompleteState(message) {
    isPolling = false;
    if (dbStatusInterval) {
      clearInterval(dbStatusInterval);
      dbStatusInterval = null;
    }
    progressBar.style.width = '100%';
    progressPercent.textContent = '100%';
    progressMessage.textContent = message || 'Sync complete!';
    updateEstimatedTime(100);

    // Show completion UI
    syncActions.classList.add('hidden');
    syncComplete.classList.remove('hidden');

    // Stop the spinner
    const syncIcon = document.querySelector('.fa-sync');
    if (syncIcon) syncIcon.classList.remove('fa-spin');

    // Final update of repo statuses
    pollDbStatus();
  }

  // Reset UI for retry
  function resetUIForRetry() {
    syncError.classList.add('hidden');
    syncComplete.classList.add('hidden');
    syncActions.classList.remove('hidden');
    progressBar.style.width = '0%';
    progressPercent.textContent = '0%';
    progressMessage.textContent = 'Starting sync...';
    estimatedTime.lastChild.textContent = ' Calculating...';
    // Reset spinner
    const syncIcon = document.querySelector('.fa-exclamation-circle');
    if (syncIcon) {
      syncIcon.classList.remove('fa-exclamation-circle');
      syncIcon.classList.add('fa-sync', 'fa-spin');
    } else {
      const existingIcon = document.querySelector('.fa-sync');
      if (existingIcon) existingIcon.classList.add('fa-spin');
    }
    lastProgressPercent = 0;
    lastProgressTime = null;

    // Reset all repo statuses to pending
    document.querySelectorAll('.repo-status').forEach(statusDiv => {
      while (statusDiv.firstChild) {
        statusDiv.removeChild(statusDiv.firstChild);
      }
      const badge = document.createElement('span');
      badge.className = 'badge badge-ghost text-base-content/50';
      const icon = document.createElement('i');
      icon.className = 'fa-solid fa-clock mr-1';
      badge.appendChild(icon);
      badge.appendChild(document.createTextNode('Pending'));
      statusDiv.appendChild(badge);
    });
  }

  // Start the sync task
  function startSync() {
    syncStartTime = Date.now();
    lastProgressTime = Date.now();

    fetch(config.startUrl, {
      method: 'POST',
      headers: {
        'X-CSRFToken': config.csrfToken,
        'Content-Type': 'application/json'
      }
    })
    .then(response => {
      // Handle 409: pipeline already in progress - poll DB status instead
      if (response.status === 409) {
        console.log('Pipeline already in progress, polling DB status');
        isPolling = true;
        progressMessage.textContent = 'Sync in progress...';
        // Start DB-only polling mode
        dbStatusInterval = setInterval(pollDbStatusWithProgress, 2000);
        pollDbStatusWithProgress();
        return null; // Skip further processing
      }
      return response.json();
    })
    .then(data => {
      if (!data) return; // 409 case handled above

      if (data.task_id) {
        currentTaskId = data.task_id;
        // Poll for progress using celery-progress
        const progressUrl = '/celery-progress/' + data.task_id + '/';
        isPolling = true;
        pollProgress(progressUrl);

        // Start DB status polling (every 2 seconds)
        dbStatusInterval = setInterval(pollDbStatus, 2000);
        // Initial poll
        pollDbStatus();
      } else if (data.error) {
        showErrorState(data.error);
      } else {
        showErrorState('Failed to start sync. Please try again.');
      }
    })
    .catch(error => {
      console.error('Error starting sync:', error);
      showErrorState('Error starting sync. Please check your connection.');
    });
  }

  // Poll DB status and update progress bar (when no Celery task ID)
  function pollDbStatusWithProgress() {
    fetch(config.statusUrl)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          console.warn('Status error:', data.error);
          return;
        }

        // Update phase indicators and details
        updatePhaseDetails(data);

        // Update individual repo statuses
        if (data.repos) {
          data.repos.forEach(repo => {
            updateRepoStatus(repo.id, repo.sync_status, repo.sync_progress, repo.last_sync_error);
          });
        }

        // For sync phase, calculate progress from repos
        const phase = data.sync_phase || data.pipeline_status;
        if (phase === 'sync' || phase === 'syncing' || phase === 'phase1' || phase === 'members' || phase === 'syncing_members') {
          let totalProgress = 0;
          let repoCount = 0;
          if (data.repos && data.repos.length > 0) {
            data.repos.forEach(repo => {
              if (repo.sync_status === 'completed') {
                totalProgress += 100;
              } else if (repo.sync_status === 'syncing') {
                totalProgress += repo.sync_progress || 0;
              }
              repoCount++;
            });
            const percent = Math.round(totalProgress / repoCount);
            progressBar.style.width = percent + '%';
            progressPercent.textContent = percent + '%';
            updateEstimatedTime(percent);
          }
        }

        // Track progress changes for stall detection
        // Check multiple signals: pipeline progress, PR count, or repo activity
        const currentProgress = data.pipeline_progress || 0;
        const currentPrCount = data.prs_synced || 0;
        const currentRepoActivity = calculateRepoActivity(data.repos);

        const hasProgress =
          currentProgress > lastProgressPercent ||
          currentPrCount > lastPrCount ||
          currentRepoActivity > lastRepoActivity;

        if (hasProgress) {
          lastProgressPercent = currentProgress;
          lastPrCount = currentPrCount;
          lastRepoActivity = currentRepoActivity;
          lastProgressTime = Date.now();
        }

        // Update message with phase and PR count
        if (data.sync_phase_label) {
          let msg = data.sync_phase_label;
          if (data.prs_synced > 0 && (phase === 'sync' || phase === 'syncing')) {
            msg += ' (' + data.prs_synced + ' PRs imported)';
          }
          progressMessage.textContent = msg;
        } else if (data.prs_synced > 0) {
          progressMessage.textContent = 'Syncing... (' + data.prs_synced + ' PRs imported)';
        }

        // Check for completion - phase1_complete means dashboard is ready
        const pipelineStatus = data.pipeline_status;
        if (pipelineStatus === 'phase1_complete' || pipelineStatus === 'complete' || pipelineStatus === 'background_syncing') {
          const msg = data.insights_ready
            ? 'Your dashboard is ready! ' + data.prs_synced + ' PRs analyzed.'
            : 'Initial sync complete! ' + data.prs_synced + ' PRs imported.';
          showCompleteState(msg);
          return;
        }

        // Check for stall (but not during LLM processing which can be slow)
        const isSlowPhase = phase === 'llm' || phase === 'llm_processing' || phase === 'insights' || phase === 'computing_insights';
        const effectiveStallTimeout = isSlowPhase ? stallTimeoutMs * 3 : stallTimeoutMs;
        if (lastProgressTime && (Date.now() - lastProgressTime > effectiveStallTimeout)) {
          showErrorState('Sync appears to be stuck. No progress in ' + Math.round(effectiveStallTimeout/1000) + ' seconds.');
          return;
        }

        // Check for failure
        if (pipelineStatus === 'failed') {
          showErrorState('Sync failed. ' + (data.pipeline_error || 'Please try again.'));
        }
      })
      .catch(error => {
        console.warn('Error fetching DB status:', error);
      });
  }

  function pollProgress(url) {
    if (!isPolling) return;

    fetch(url)
      .then(response => response.json())
      .then(data => {
        if (!isPolling) return;

        // Check for task failure
        if (data.state === 'FAILURE' || data.state === 'REVOKED') {
          showErrorState('Sync task failed. ' + (data.result?.error || 'Please try again.'));
          return;
        }

        if (data.complete) {
          showCompleteState(data.result?.message);
        } else if (data.progress) {
          // Update progress
          const percent = Math.round((data.progress.current / data.progress.total) * 100);
          progressBar.style.width = percent + '%';
          progressPercent.textContent = percent + '%';
          updateEstimatedTime(percent);
          if (data.progress.description) {
            progressMessage.textContent = data.progress.description;
          }

          // Track progress changes for stall detection
          if (percent > lastProgressPercent) {
            lastProgressPercent = percent;
            lastProgressTime = Date.now();
          }

          // Check for stall (no progress for stallTimeoutMs)
          if (lastProgressTime && (Date.now() - lastProgressTime > stallTimeoutMs)) {
            showErrorState('Sync appears to be stuck. No progress in ' + Math.round(stallTimeoutMs/1000) + ' seconds.');
            return;
          }

          // Continue polling
          setTimeout(() => pollProgress(url), 1000);
        } else {
          // No progress yet - could be pending or task not started
          // Check for stall from initial state
          if (lastProgressTime && (Date.now() - lastProgressTime > stallTimeoutMs)) {
            showErrorState('Sync task may not have started. Please try again.');
            return;
          }

          // Keep polling
          setTimeout(() => pollProgress(url), 1000);
        }
      })
      .catch(error => {
        console.error('Error polling progress:', error);
        // Retry after a delay (network issues)
        setTimeout(() => pollProgress(url), 2000);
      });
  }

  // Retry button handler
  retrySyncBtn.addEventListener('click', function() {
    resetUIForRetry();
    startSync();
  });

  // Initial sync start
  startSync();
});
</script>
{% endblock %}
